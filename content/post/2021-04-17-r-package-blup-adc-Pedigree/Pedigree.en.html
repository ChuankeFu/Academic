---
title: 'R package:blupADC-使用说明3'
author: qsmei
date: '2021-04-16'
slug: Pedigree
categories:
  - pedigree
tags: []
subtitle: ''
summary: '系谱数据追溯与重命名'
authors: []
lastmod: '2021-04-16T09:32:43+08:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

<script src="/rmarkdown-libs/header-attrs/header-attrs.js"></script>


<p>🦄大家好,这一节主要给大家讲述的是如何使用<code>blupADC</code>中的函数来进行系谱数据处理。<code>blupADC</code>提供的<code>trace_pedigree</code>函数，可以帮助我们非常方便的对系谱数据进行多种处理:包括系谱重命名、系谱追溯及系谱纠错等。</p>
<p>💖同样的，我们还是用一个小例子来简单的看下该函数的用法</p>
<pre class="r"><code>library(blupADC)
data_pedigree=data.table::fread(&quot;D:/test_code/BLUP_ADC_code/test_data/ped.txt&quot;,data.table=F)
colnames(data_pedigree)=c(&quot;Offspring&quot;,&quot;Sire&quot;,&quot;Dam&quot;,&quot;Birth_Date&quot;)
pedigree_result=trace_pedigree(input_pedigree=data_pedigree,output_pedigree_tree=TRUE)
## Peidgree provided has four columns,please make sure the format of pedigree data has four columns: Offspring Sire Dam  Birth_Date 
## Trace full generation......</code></pre>
<p>我们可以通过<code>str</code>查看函数的输出结果，如下所示:</p>
<pre class="r"><code>str(pedigree_result)
## List of 5
##  $ ped             : chr [1:42149, 1:3] &quot;YYHZAUT14003572&quot; &quot;YYHZAUT17786901&quot; &quot;YYHZAUT16532401&quot; &quot;YYHZAUT15162815&quot; ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : NULL
##   .. ..$ : chr [1:3] &quot;Offspring&quot; &quot;Sire&quot; &quot;Dam&quot;
##  $ rename_ped      :&#39;data.frame&#39;:    42149 obs. of  6 variables:
##   ..$ Offspring   : chr [1:42149] &quot;YYHZAUT14003572&quot; &quot;YYHZAUT17786901&quot; &quot;YYHZAUT16532401&quot; &quot;YYHZAUT15162815&quot; ...
##   ..$ Generation  : num [1:42149] 0 0 0 0 0 0 0 0 0 0 ...
##   ..$ Offspring_Id: int [1:42149] 1 2 3 4 5 6 7 8 9 10 ...
##   ..$ Sire_Id     : num [1:42149] 0 0 0 0 0 0 0 0 0 0 ...
##   ..$ Dam_Id      : num [1:42149] 0 0 0 0 0 0 0 0 0 0 ...
##   ..$ Order       : int [1:42149] 1 2 3 4 5 6 7 8 9 10 ...
##  $ pedigree_tree   : chr [1:42149, 1:15] &quot;YYHZAUT14003572&quot; &quot;YYHZAUT17786901&quot; &quot;YYHZAUT16532401&quot; &quot;YYHZAUT15162815&quot; ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : NULL
##   .. ..$ : chr [1:15] &quot;Offspring&quot; &quot;Sire&quot; &quot;Dam&quot; &quot;SireSire&quot; ...
##  $ rename_phenotype: NULL
##  $ error_id_set    :List of 4
##   ..$ error_duplicated_id: NULL
##   ..$ error_sex_id       : chr(0) 
##   ..$ error_breed_id     : NULL
##   ..$ error_birth_date_id: NULL</code></pre>
<p>可以很明显的看到,输出结果包括以下几个部分:</p>
<ul>
<li><p><strong>ped:</strong> 经过处理后(纠错、追溯等)的原始系谱数据且未进行重命名</p></li>
<li><p><strong>rename_ped:</strong> 经过处理(纠错、追溯等)且重命名的系谱数据。第1列为原始系谱ID,第2列为个体在系谱中的代数，第3-5列为重命名后的系谱数据</p></li>
<li><p><strong>pedigree_tree:</strong>个体的系谱树矩阵。可以通过设置 pedigree_tree_depth指定系谱树包含的代数，默认不输出系谱树(节省时间)</p></li>
<li><p><strong>error_id_set:</strong>系谱记录错误个体数据集。根据错误的种类可以分为以下4个子集</p></li>
</ul>
<ol style="list-style-type: decimal">
<li><p>error_duplicated_id:相同的个体，父母却不相同</p></li>
<li><p>error_sex_id:个体同时出现在父亲列和母亲列</p></li>
<li><p>error_breed_id: 个体和父母的品种不相同(仅针对特殊格式)</p></li>
<li><p>error_birth_date_id: 个体的出生日期要早于父母的出生日期(需在系谱的第四列提供个体的出生日期)</p></li>
</ol>
<p>下面，我们将具体讲解<code>trace_pedigree</code>函数中各种参数的含义:</p>
<div id="主要参数" class="section level3">
<h3>💥主要参数</h3>
<ul>
<li><strong>参数1：input_pedigree</strong></li>
</ul>
<p>用户提供的系谱数据，<code>data.frame</code>或 <code>matrix</code>类型。</p>
<p>💌用户提供系谱数据需为以下几种格式中的一种，包括：</p>
<ul>
<li>3列系谱格式:</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Offspring</th>
<th align="left">Sire</th>
<th align="left">Dam</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">YYHZAUT19173108</td>
<td align="left">YYHZAUT17282102</td>
<td align="left">YYHZAUT16109011</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">YYHZAUT19628606</td>
<td align="left">YYHZAUT18811301</td>
<td align="left">YYHZAUT18884508</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">YYHZAUT19423809</td>
<td align="left">YYHZAUT18336401</td>
<td align="left">YYHZAUT18623508</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">YYHZAUT20898011</td>
<td align="left">YYHZAUT18718802</td>
<td align="left">YYHZAUT18859712</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">YYHZAUT20268616</td>
<td align="left">YYHZAUT19541201</td>
<td align="left">YYHZAUT18802408</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">YYHZAUT19653108</td>
<td align="left">YYHZAUT18747603</td>
<td align="left">YYHZAUT18898606</td>
</tr>
</tbody>
</table>
<ul>
<li>4列系谱格式:</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="left"></th>
<th align="left">Offspring</th>
<th align="left">Sire</th>
<th align="left">Dam</th>
<th align="right">Birth_Date</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">1</td>
<td align="left">YYHZAUT19173108</td>
<td align="left">YYHZAUT17282102</td>
<td align="left">YYHZAUT16109011</td>
<td align="right">20190208</td>
</tr>
<tr class="even">
<td align="left">2</td>
<td align="left">YYHZAUT19628606</td>
<td align="left">YYHZAUT18811301</td>
<td align="left">YYHZAUT18884508</td>
<td align="right">20191012</td>
</tr>
<tr class="odd">
<td align="left">3</td>
<td align="left">YYHZAUT19423809</td>
<td align="left">YYHZAUT18336401</td>
<td align="left">YYHZAUT18623508</td>
<td align="right">20190615</td>
</tr>
<tr class="even">
<td align="left">4</td>
<td align="left">YYHZAUT20898011</td>
<td align="left">YYHZAUT18718802</td>
<td align="left">YYHZAUT18859712</td>
<td align="right">20200307</td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">YYHZAUT20268616</td>
<td align="left">YYHZAUT19541201</td>
<td align="left">YYHZAUT18802408</td>
<td align="right">20200827</td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">YYHZAUT19653108</td>
<td align="left">YYHZAUT18747603</td>
<td align="left">YYHZAUT18898606</td>
<td align="right">20191018</td>
</tr>
</tbody>
</table>
<ul>
<li>多列系谱格式:</li>
</ul>
<table style="width:100%;">
<colgroup>
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
<col width="16%" />
</colgroup>
<thead>
<tr class="header">
<th align="left">Offspring</th>
<th align="left">Sire</th>
<th align="left">Dam</th>
<th align="left">SireSire</th>
<th align="left">DamSire</th>
<th align="left">SireSireSire</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">YYHZAUT19682603</td>
<td align="left">YYHZAUT18498306</td>
<td align="left">YYHZAUT18881607</td>
<td align="left">YYHZAUT17517904</td>
<td align="left">YYHZAUT17060205</td>
<td align="left">YYHZAUT15421201</td>
</tr>
<tr class="even">
<td align="left">YYHZAUT19292804</td>
<td align="left">YYHZAUT17217601</td>
<td align="left">YYHZAUT18443906</td>
<td align="left">YYHZAUT16762403</td>
<td align="left">YYHZAUT16360601</td>
<td align="left">YYHZAUT15129404</td>
</tr>
<tr class="odd">
<td align="left">YYHZAUT19215806</td>
<td align="left">YYHZAUT18412205</td>
<td align="left">YYHZAUT16113613</td>
<td align="left">YYHZAUT17412001</td>
<td align="left">YYHZAUT15289901</td>
<td align="left">YYHZAUT15288601</td>
</tr>
<tr class="even">
<td align="left">YYHZAUT20245109</td>
<td align="left">YYHZAUT19584301</td>
<td align="left">YYHZAUT18916603</td>
<td align="left">YYHZAUT18747603</td>
<td align="left">YYHZAUT17060205</td>
<td align="left">YYHZAUT17642901</td>
</tr>
<tr class="odd">
<td align="left">YYHZAUT19528301</td>
<td align="left">YYHZAUT18537302</td>
<td align="left">YYHZAUT18643307</td>
<td align="left">YYHZAUT17603803</td>
<td align="left">YYHZAUT17656604</td>
<td align="left">YYHZAUT16766003</td>
</tr>
<tr class="even">
<td align="left">YYHZAUT19588602</td>
<td align="left">YYHZAUT18691101</td>
<td align="left">YYHZAUT17250213</td>
<td align="left">YYHZAUT17739601</td>
<td align="left">YYHZAUT17411802</td>
<td align="left">YYHZAUT16126301</td>
</tr>
</tbody>
</table>
<p><strong>Note</strong>:需要注意的是，当系谱为多列时，系谱的列名需要标注为特殊形式,e.g. SireSire:父亲的父亲, SirSireSire:父亲的父亲的父亲</p>
<p>系谱数据中缺失值可以设置为: <strong>NA或0</strong>。</p>
<p>同样的，为了便于用户操作，用户还可以直接提供本地系谱数据的路径和名称</p>
<ul>
<li><strong>参数2：input_pedigree_path</strong></li>
</ul>
<p>本地系谱数据的路径,<code>character</code>类型。</p>
<ul>
<li><strong>参数3：input_pedigree_name</strong></li>
</ul>
<p>本地系谱数据的名称，<code>character</code>类型。</p>
<ul>
<li><strong>参数4：pedigree_format_conversion</strong></li>
</ul>
<p>是否将提供的多列系谱转换到3列，logical类型。如果用户提供的系谱数据包含多列，那么用户必须设置<code>pedigree_format_conversion=TRUE</code> 。</p>
<ul>
<li><strong>参数5：output_pedigree_type</strong></li>
</ul>
<p>系谱输出的格式，<code>character</code>类型。可选格式包括: BLUPF90, DMU 及 Normal(未重命名)。</p>
<ul>
<li><strong>参数6：output_pedigree_path</strong></li>
</ul>
<p>系谱输出到本地的路径，<code>character</code>类型。</p>
<ul>
<li><strong>参数7：output_pedigree_name</strong></li>
</ul>
<p>系谱输出到本地的名称，<code>character</code>类型。</p>
</div>
<div id="其他参数" class="section level3">
<h3>💨其他参数</h3>
<ul>
<li><strong>参数8：dup_error_check</strong></li>
</ul>
<p>检查相同个体的父母却不相同的错误，<code>logical</code>类型，默认为TRUE。</p>
<ul>
<li><strong>参数9：sex_error_check</strong></li>
</ul>
<p>检查个体同时出现在父亲列和母亲列的错误，<code>logical</code>类型，默认为TRUE。</p>
<ul>
<li><strong>参数10：breed_error_check</strong></li>
</ul>
<p>检查个体品种与父母品种不同的错误，<code>logical</code>类型，默认为FALSE。</p>
<ul>
<li><strong>参数11：birth_date_error_check</strong></li>
</ul>
<p>检查个体出生日期早于父母的错误，<code>logical</code>类型，默认为FALSE。</p>
<ul>
<li><strong>参数12：trace_id</strong></li>
</ul>
<p>追溯系谱记录的个体号，<code>character</code>类型，默认为<code>NULL</code>(追溯系谱中所有的个体)。</p>
<ul>
<li><strong>参数13：trace_offspring</strong></li>
</ul>
<p>是否追溯子代，<code>logical</code>类型，默认为FALSE。</p>
<ul>
<li><strong>参数14：trace_generation</strong></li>
</ul>
<p>追溯的代数，<code>numeric</code>类型，默认为5。</p>
<ul>
<li><strong>参数15：trace_birth_date</strong></li>
</ul>
<p>追溯出生日期晚于指定日期的个体，<code>character</code>类型。</p>
<ul>
<li><strong>参数16：output_pedigree_tree</strong></li>
</ul>
<p>是否输出系谱树，<code>logical</code>类型，默认为FALSE。</p>
<ul>
<li><strong>参数17：pedigree_tree_depth</strong></li>
</ul>
<p>系谱树的深度(系谱代数)，<code>numeric</code>类型，默认为3。</p>
</div>
